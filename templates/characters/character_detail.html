{% extends 'base.html' %}



{% block content %}

<div style="display:none;">
  {% csrf_token %}
</div>

<div class="page-container">

    <div class="Hero-Section">
        <h1>{{character.name}}</h1>
        <br>
        <h3>{{character.character_class}}</h3>
        <p>XP: {{character.xp}}</p>
    </div>

    <div class="two-column-section">

    <div class="left-column">

        <div class="banner">
            <h1>ğŸ“‹ Attributes</h1>
        </div>

        <!-- this container holds primary attributes such as agility, cunning etc -->
        <div class="attribute-container">
             <div class="attribute-card">
                <h1>âš¡ï¸</h1>
                <p>agility</p>
                <h1>{{character.agility}}</h1>
             </div>
        
             <div class="attribute-card">
                <h1>ğŸ§ </h1>
                <p>Cunning</p>
                <h1>{{character.cunning}}</h1>
             </div>
    
             <div class="attribute-card">
                <h1>ğŸ‘»</h1>
                <p>spirit</p>
                <h1>{{character.spirit}}</h1>
             </div>

             <div class="attribute-card">
                <h1>ğŸ’ª</h1>
                <p>strength</p>
                <h1>{{character.strength}}</h1>
             </div>

             <div class="attribute-card">
                <h1>ğŸ“–</h1>
                <p>lore</p>
                <h1>{{character.lore}}</h1>
             </div>

             <div class="attribute-card">
                <h1>ğŸ²</h1>
                <p>luck</p>
                <h1>{{character.luck}}</h1>
             </div>
        </div> <!-- attribute container-->



        <div class="banner">
            <h1>âš”ï¸ Combat</h1>
        </div>

        <!-- this container holds combat information -->
        <div class="attribute-container">
             <div class="attribute-card">
                <h1>ğŸƒ</h1>
                <p>Initiative</p>
                <h1>{{character.initiative}}</h1>
             </div>
        
             <div class="attribute-card">
                <h1>ğŸ¹</h1>
                <p>Range</p>
                <h1>{{character.range}}+</h1>
             </div>
    
             <div class="attribute-card">
                <h1>ğŸ—¡ï¸</h1>
                <p>Melee | combat:  <span style="font-size: 1.5em; font-weight: bold;">{{character.combat}}</span> </p>
                <h1>{{character.melee}}+</h1>
             </div>
        </div> <!-- attribute container-->


        <div class="banner">
            <h1>ğŸ«€ Vitality</h1>
        </div>

        <div class="vitality-container">

        <div class="vital-card">
            <div class="vital-label">â¤ï¸ Health</div>
            <div class="vital-label">ğŸ›¡ï¸ Armor: <span style="font-size: 1.2em;">{{character.armor}}</span></div>
            <div class="vital-bar">
                <div class="vital-fill" style="width:{{character.calculated_health}}%"></div>
                <div class="vital-text">{{character.health}} / {{character.max_health}}</div>
            </div>
        </div>

        </div> <!-- vitality card-->


    </div> <!-- Left conainter-->
    
    <div class="right-column">
        <!-- Your right side content here -->
    </div>
</div>


        

    




</div>

<script>
// Get CSRF token from the hidden div
function getCSRFToken() {
    return document.querySelector('[name=csrfmiddlewaretoken]').value;
}

// Get the current URL (character detail page URL)
const currentURL = "{% url 'character_detail' character.pk %}";

// DOM elements
const cycleBtn = document.getElementById('CycleAbilityBtn');

// Utility function to send and receive data from backend
async function fetchData(url, dataDict) {
    try {
        // convert the dataDict into something the 
        const formBody = new URLSearchParams(dataDict).toString();

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCSRFToken(),
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: formBody
        });

        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Something went wrong');
        }

        return data; // returns the backend's response as a dictionary
    } catch (error) {
        console.error('Error in fetchData:', error);
        throw error; // propagate error to caller
    }
}


cycleBtn.addEventListener('click', async function() {
    // elements that will be updated
    const abilityNameEl = document.getElementById('CurrentAbilityName');
    const abilityDescEl = document.getElementById('CurrentAbilityDescription');

    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, { action: 'cycle_ability' });

        // if there is a valid response
        if (data.new_ability_name) {
            abilityNameEl.textContent = data.new_ability_name;
            abilityDescEl.textContent = data.new_ability_description;
        } else {
            abilityNameEl.textContent = 'No Abilities';
            abilityDescEl.textContent = 'No abilities available';
        }

    } catch (error) {
        alert('Failed to cycle ability: ' + error.message);
    }
});


async function update_health(num){
    health_label = document.getElementById('health_stat')
    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, { action: 'health', amount: num});

        // if there is a valid response
        if (data.health !== undefined) {
            health_label.textContent = `${data.health} / ${data.max_health}`
        } 
    } catch (error) {
        alert('Failed to cycle ability: ' + error.message);
    }
}

async function update_sanity(num){
    sanity_label = document.getElementById('sanity_stat')
    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, { action: 'sanity', amount: num});

        // if there is a valid response
        if (data.sanity !== undefined) {
            sanity_label.textContent = `${data.sanity} / ${data.max_sanity}`
        } 
    } catch (error) {
        alert('Failed to cycle ability: ' + error.message);
    }
}

async function update_horror(num){
    horror_label = document.getElementById('horror_stat')
    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, { action: 'horror', amount: num });

        // if there is a valid response
        if (data.horror !== undefined) {
            horror_label.textContent = `${data.horror} / ${data.max_horror}`
        } 
    } catch (error) {
        alert('Failed to cycle ability: ' + error.message);
    }
}

async function update_grit(num){
    grit_label = document.getElementById('grit_stat')
    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, { action: 'grit', amount: num });

        // if there is a valid response
        if (data.grit !== undefined) {
            grit_label.textContent = `${data.grit} / ${data.max_grit}`
        } 
    } catch (error) {
        alert('Failed to cycle ability: ' + error.message);
    }
}



async function update_gold(num) {
    const gold_label = document.getElementById('gold_stat');

    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, {
            action: 'gold',
            amount: num
        });

        // if there is a valid response
        if (data.gold !== undefined) {
            gold_label.textContent = `Gold: ${data.gold}`;
        }
    } catch (error) {
        alert('Failed to update gold: ' + error.message);
    }
};

async function update_dark_stone(num) {
    const dark_stone_label = document.getElementById('dark_stone_stat');

    try {
        // send data into the back end and get the response
        const data = await fetchData(currentURL, {
            action: 'dark_stone',
            amount: num
        });

        // if there is a valid response
        if (data.dark_stone !== undefined) {
            dark_stone_label.textContent = `Dark Stone: ${data.dark_stone}`;
        }
    } catch (error) {
        alert('Failed to update Dark Stone: ' + error.message);
    }
};

async function update_xp(num) {
    const xp_label = document.getElementById('xp_stat');

    try {
        const data = await fetchData(currentURL, {
            action: 'xp',
            amount: num
        });

        if (data.xp !== undefined) {
            xp_label.textContent = `XP: ${data.xp}`;
        }
    } catch (error) {
        alert('Failed to update XP: ' + error.message);
    }
};


function resizeText(el, maxSize, minSize, scale = 0.6) {
    const length = el.textContent.trim().length;

    // Calculate size based on text length
    let size = maxSize - length * scale;

    // Clamp size
    size = Math.max(minSize, Math.min(maxSize, size));

    el.style.fontSize = size + "px";
}

function resizeAllTokens() {
    document.querySelectorAll(".token_card h1").forEach(h1 => {
        resizeText(h1, 32, 25, 0.7);
    });

    document.querySelectorAll(".token_card p").forEach(p => {
        resizeText(p, 30, 25, 0.4);
    });
}


</script>
{% endblock content %}



